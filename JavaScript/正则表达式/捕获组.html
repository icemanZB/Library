<!DOCTYPE html>
<html>
<head lang="en">
	<meta charset="UTF-8">
	<title>捕获组</title>
	<script>
		// 捕获组就是把正则表达式中子表达式匹配的内容，保存到内存中以数字编号或显示命名的组里，方便后面使用;可以在正则表达式内部使用，也可以在外部使用

		// 捕获组有2种：一种是捕获性分组，另一种是非捕获性分组;

		// 捕获组分组语法：(Expression)

		// 中括号是表示范围内选择，大括号表示重复次数，小括号的含义是允许重复多个字符

		// 捕获性分组的编号规则：编号是按照 "(" 出现的顺序，从左到右，从 1 开始进行编号

		// 分组的列子
		console.log(/(longen){2}/.test("longen")); // false
		console.log(/(longen){2}/.test("longenlongen")); // true
		// 分组的运用 RegExp.$1 获取小括号的分组
		var str = 11122;
		/(\d+)/.test(str);
		console.log(RegExp.$1); // 11122

		// 使用 replace 替换，使用分组把内容替换
		var num = "11 22";
		var n = num.replace(/(\d+)\s*(\d+)/, "$2 $1");
		console.log(n); // 22 11


		// 非捕获性分组

		// 并不是所有分组都能创建反向引用，有一种分组叫做非捕获性分组，它不能创建反向引用，要创建一个非捕获性分组，只要在分组的左括号的后面紧跟一个问号与冒号就 ok
		// 非捕获分组的含义我们可以理解为如下：子表达式可以作为被整体修饰但是子表达式匹配的结果不会被存储
		// 非捕获性分组
		var num2 = "11 22";
		/#(?:\d+)/.test(num2);
		console.log(RegExp.$1); // ""
		// 我们再来看下使用，非捕获性分组来把页面上的所有标签都去掉
		// 把页面上所有的标签都移除掉
		var html = "<p><a href='http://baidu.com'>我来测试下</a>by <em>龙恩</em></p>";
		var text = html.replace(/<(?:.|\s)*?>/g, "");
		console.log(text); // 我来测试下 by 龙恩

		// 分析下：正则/<(?:.|\s)*?>/g 的含义是：g 是修饰符，全局匹配的含义; 使用非捕获性分组 ?: 的含义是，子表达式可以作为被整体修饰但是子表达式匹配的结果不会被存储
		// 因此，正则/<(?:.|\s)*?>/g 的含义变为：匹配以< 开头 及 > 结束的所有字符;(?:.|\s)*? 含义是 . 代表任意字符，| 含义是或者的意思，\s 是匹配空格的意思
		// *号修饰符的含义是零个或者多个的意思; 后面的?(问号)代表可匹配,可不匹配的含义;优先是可匹配
		// 总起来的意思是：全局匹配字符串 html 中的 以<开头 以>结尾的所有字符替换成空字符串，因此留下来就是文本

		// 反向引用
		// 反向引用标识由正则表达式中的匹配组捕获的子字符串。每个反向引用都由一个编号或名称来标识;并通过 "\编号" 表示法来进行引用

		console.log(/(longen)\1/.test("longen")); // false

		console.log(/(longen)\1/.test("longenlongen")); // true

		// 反向引用详细讲解

		// 捕获性分组取到的内容，不仅可以在正则表达式外部通过程序进行引用，也可以在正则表达式内部进行引用，这种引用方式就叫做反向引用

		// 反向引用的作用是：是用来查找或限定重复，查找或限定指定标识配对出现等

		// 捕获性分组的反向引用的写法如：\number   Number是十进制数字，即捕获组的编号

		// 反向引用的匹配原理

		// 捕获分组在匹配成功时，会将子表达式匹配到的内容，保存到内存中一个以数字编号的组里，可以简单的认为是对一个局部变量进行了赋值
		// 这时就可以通过反向引用，引用这个局部变量的值。一个捕获分组在匹配成功之前，它的内容可以是不确定的，一旦匹配成功了它的内容就确定了，反向引用的内容也就确定了

		var str2 = "longenaabcd";
		console.log(str2.match(/([ab])\1/)[0]); // aa

		// 代码分析 : 对于如上代码中的正则 /([ab])\1/，捕获组中子表达式 [ab];可以匹 配a，也可以匹配 b，但是如果匹配成功的话，那么它的反向引用也就确定了
		// 如果捕获分组匹配到的是 a，那么它的反向引用就只能匹配a，如果捕获分组匹配到的是 b，那么它的反向引用就只能匹配到 b
		// \1的含义是捕获分组匹配到是什么，那么它必须与捕获分组是相同的字符;也就是说只能匹配到 aa 或者 bb 才能匹配成功

		// 该正则匹配的过程分析如下

		// 字符串匹配正则 /([ab])\1/，在位置 0 处开始匹配，0 处字符是 l ，很明显不满足，把控制权就交给下一个字符，一直到第 6 个字符，才匹配到 a，匹配成功，把控制权交给 \1
		// 也就是反向引用和分组中是相同的字符，因此也匹配 a，字符串中下一个字符也是 a，因此匹配成功，因此整个表达式找到匹配的字符，匹配的位置开始于 6，结束与 8
		// 我们再可以匹配b，原理和上面一样

	</script>
</head>
<body>

</body>
</html>