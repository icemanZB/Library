// "暂时性死区" 也意味着 typeof 不再是一个百分之百安全的操作
typeof x; // ReferenceError
let x;
/*
 * 上面代码中，变量 x 使用 let 命令声明，所以在声明之前，都属于 x 的 "死区"，只要用到该变量就会报错。因此，typeof 运行时就会抛出一个 ReferenceError
 * 作为比较，如果一个变量根本没有被声明，使用 typeof 反而不会报错。
 */

typeof undeclared_variable; // "undefined"
/*
 * 上面代码中，undeclared_variable 是一个不存在的变量名，结果返回 "undefined"。
 * 所以，在没有 let 之前，typeof 运算符是百分之百安全的，永远不会报错。
 * 现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。
 */

// 有些 "死区" 比较隐蔽，不太容易发现
function bar(x = y, y = 2) {
	return [x, y];
}

bar(); // 报错

// 上面代码中，调用 bar 函数之所以报错 ( 某些实现可能不报错 )，是因为参数 x 默认值等于另一个参数 y，而此时 y 还没有声明，属于 "死区"。
// 如果 y 的默认值是 x，就不会报错，因为此时 x 已经声明了
function bar1(x1 = 2, y1 = x1) {
	return [x1, y1];
}
bar1(); // [2, 2]

// ES6 规定暂时性死区和不存在变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。
// 这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。
// 总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。