<!DOCTYPE html>
<html>
<head lang="en">
	<meta charset="utf-8">
	<title>隐式类型转换</title>
	<script>
		/*
		 * 隐式转换类型
		 * 计算机自动的先把 num 和 str 转为相同的类型，在进行比较
		 * 双等号 先转换类型在比较
		 * 全等不转换类型直接比
		 */

		var num = 5;
		var str = "5";

		console.log(num == str); // true  双等号 先转换类型在比较

		console.log(num === str); // false  全等 不转换类型 直接比

		var a = "12";
		var b = "5";

		console.log(a + b); // 125 字符串链接
		console.log(a - b); // 7 做减法之前 先把 a 和 b 转为数字 然后在去相减

		// 空数组+空数组，先调用 valueOf() 返回空数组本身，再调用 toString()，返回空字符串
		// [] + [] =""

		// [] + {} => "[object Object]"  [] 得到 ""，{} 得到 "[object Object]"

		// {} + [] => 0 {} 被视作代码块省略，+[] 就是将 [] 转换为数值的意思了得到 0

		// {} + {} => 0 同样 {} 被当做代码块省略了，+{}转数值得到NaN

		// 如果第一个空对象不被当做空代码块的话

		// ({}) + {} => "[object Object][object Object]"
		// ({} + {}) =>  "[object Object][object Object]"
		// console.log({} + {}) "[object Object][object Object]"
		//  var a = {} + {}; "[object Object][object Object]"

		// 当+运算符作为数值运算符放在其他值前面的时候，可以用于将任何值转为数值，就像Number函数那样
		// +true => 1
		// +[] => 0
		// +{} => NaN

		// {a:1} + 1 => 1  {a:1} 被当做了代码块处理，而这个代码块没有返回值，所以整个表达式就返回1了
		// ({a:1})+1 => "[object Object]1" 但是放在了圆括号中的 {a:1}，因为 JavaScript 预期 () 中是一个值，所以它就又被当做对象处理了

		// ! 取反运算符，连续对同一个值进行取反运算等于将其转换为对应的布尔值，就像 Boolean 函数那样
		// !!x => Boolean(x)

		// 如果我们想排除 null 这个对象，因为 !!null 值是 false，其他的 object，!!obj 值都是 true
		if (!!x) {
			// do something!
		}

		// ^ 异或运算符
		// 两次异或运算交换两个数的值

		var aNum = 10;
		var bNum = 99;

		aNum ^= bNum, bNum ^= aNum, aNum ^= bNum;

		console.log(aNum, bNum); // 99，10

		// 数据类型转换
		// []+1+3  // 结果为 "" + 1 -> "1" + 3 -> "13"
		// [1]+3   // 结果为 13
		// null+1+3  // 结果为 4

		// 转换成数字
		// +x  // 使用一个一元的加号运算符，这是最快的方法
		// x-0 或 x*1 // 另一种形式
		// Number(x)  // 使用不带 new 的数字构造函数进行转换

		// 对象和函数总是被转换成 NaN，undefined 也会被转换成 NaN，但 null 会被转换成 0
		console.log(+[]);  // 结果为 0
		console.log(+[1]); // 结果为 1
		console.log(+[1, 2]); //结果为NaN
		console.log(+new Array(1)); // 结果为 0
		console.log(+new Array(1, 2)); // 结果为 NaN


	</script>
</head>
<body></body>
</html>
