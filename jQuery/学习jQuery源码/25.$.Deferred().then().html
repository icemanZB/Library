<!DOCTYPE html>
<html>
<head lang="en">
	<meta charset="UTF-8">
	<title>分离$.Deferred()</title>
	<script src="jquery-2.0.3.read.js"></script>
	<script>
		function Deferred(func) {
			var tuples   = [
				    // action, add listener, listener list, final state
				    ["resolve", "done", jQuery.Callbacks("once memory"), "resolved"],
				    ["reject", "fail", jQuery.Callbacks("once memory"), "rejected"],
				    ["notify", "progress", jQuery.Callbacks("memory")]
			    ],
			    state    = "pending",
			    promise  = {
				    state  : function () {
					    return state;
				    },
				    always : function () {
					    deferred.done(arguments).fail(arguments);
					    return this;
				    },
				    /**
				     * then() 返回一个新的 deferred 对象，而 done() 返回的是原有的 deferred 对象。
				     * 如果 then() 指定的回调函数有返回值，该返回值会作为参数，传入后面的回调函数
				     */
				    then   : function (/* fnDone, fnFail, fnProgress */) {
					    var fns = arguments;
					    /**
					     * 这里 return jQuery.Deferred() 是为了 给下面的 pipe() 使用
					     */
					    return jQuery.Deferred(function (newDefer) {
						    jQuery.each(tuples, function (i, tuple) {
							    var action = tuple[0],
							        /**
							         * 找到参数中的每一个函数，判断是不是函数，如果不是函数就是 fn = false
							         */
							        fn     = jQuery.isFunction(fns[i]) && fns[i];
							    // deferred[ done | fail | progress ] for forwarding actions to newDefer
							    /**
							     * 添加回调函数  deferred["done"](function(){});
							     */
							    deferred[tuple[1]](function () {
								    /**
								     * 如果是函数，就执行这个函数并且带入 arguments 例如：dfd.resolve("hi"); 此时的 arguments 就是 "hi"
								     */
								    var returned = fn && fn.apply(this, arguments);
								    if (returned && jQuery.isFunction(returned.promise)) {
									    /**
									     * 这里是提供给 pipe() 的，会直接触发 done | fail | progress
									     */
									    returned.promise()
											    .done(newDefer.resolve)
											    .fail(newDefer.reject)
											    .progress(newDefer.notify);
								    } else {
									    /**
									     * 如果返回的是字符串的情况
									     * var newDfd = dfd.pipe(function () {
									     *     return arguments[0] + " world";
									     * });
									     *
									     * fn ? [ returned ] : arguments fn 有的话取 return 的值，没有的话取 arguments
									     */
									    newDefer[action + "With"](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments);
								    }
							    });
						    });
						    fns = null;
					    }).promise();
				    },
				    // Get a promise for this deferred
				    // If obj is provided, the promise aspect is added to the object
				    promise: function (obj) {
					    return obj != null ? jQuery.extend(obj, promise) : promise;
				    }
			    },
			    deferred = {};

			// Keep pipe for back-compat
			promise.pipe = promise.then;

			// Add list-specific methods
			jQuery.each(tuples, function (i, tuple) {
				var list        = tuple[2],
				    stateString = tuple[3];

				// promise[ done | fail | progress ] = list.add
				promise[tuple[1]] = list.add;

				// Handle state
				if (stateString) {
					list.add(function () {
						// state = [ resolved | rejected ]
						state = stateString;

						// [ reject_list | resolve_list ].disable; progress_list.lock
					}, tuples[i ^ 1][2].disable, tuples[2][2].lock);
				}

				// deferred[ resolve | reject | notify ]
				deferred[tuple[0]] = function () {
					deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments);
					return this;
				};
				deferred[tuple[0] + "With"] = list.fireWith;

			});

			// Make the deferred a promise
			promise.promise(deferred);

			// Call given func if any
			if (func) {
				func.call(deferred, deferred);
			}

			// All done!
			return deferred;
		}

		var dfd = Deferred();
		dfd.then(function (preVale) {
			console.log(2 * preVale); // 4
			return 2 * preVale;
		}).then(function (preVale) {
			console.log(3 * preVale); // 12
			return 3 * preVale;
		});

		dfd.resolve(2);

		var defer = Deferred();

		defer.then(function (value) {
			return value * 2;
		}).then(function (value) {
			return value * 2;
		}).done(function (value) {
			console.log(value);  // 20
		});

		defer.resolve(5);

	</script>
</head>
<body>

</body>
</html>